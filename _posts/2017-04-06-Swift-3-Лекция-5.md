## Структури и класове, смесени типове (tuples)

Комбинирани типове данни?

До сега се запознахме с основните типове данни в прогрмния език Swift - `Int`, `Double`, `String`, `Bool`, `Array`. Това ни дава възможността да решаваме много задачи, но е време да въведем типове данни, които ще ни дадат свобода да моделираме по-сложни системи в нашите програми. Например, за да реализираме система за онлайн магазин - ние трябва да можем да представим всеки един продукт. Един продукт има различни характеристики. Нека да изброим някои основни - име на продукта (`String`), цена на бройка (`Double`), наличен ли е или не (`Bool`). Със знанията ни до момента, най-близкият начин за моделиране е да изпозлваме N-торките (вързопчетата с данни от различни типове). 

## Структури

Структуте са основн единица носител на данни в програмите. По значимост те се нареждат до функциите, основните типове и изброимте типове. По-късно ще се запознаем с класовете, които са близки до структурите, но имат някои основни различия. 

Структурите са сложен тип от данни, който обединява няколко различни типа и дава възможност за лесно боравене с тях. До тук можем да си милсим за N-торките (tuples), но към структурите можем да добавяме операции. Т.е. можем да определяме функции, които да са част от интерфейса на структура, която да борави със данните в самата структура. Функциите, които познаваме до момента, могат да изпълняват тези задачи, но е много по лесно и интуитивно, да се разсъждава от гледан точка на структурата в сравнение с глобалната гледна точка, която е типична за глобалните функции.

При някои програмни езици декларацията на интерфейса на структуира и дефиницията (логиката и организацията) стоят в различни файлове. Това не е характерно за Swift, тук всичко се намира в един файл.

Нека да видим пример за структура, която може да опише една стока от онлайн магазин.

```swift
struct Merchandise {
	var name: String
	var pricePerUnit: Double
	var isAvailable: Bool
}
```

Това, което забелязваме, е че можем да се обръшаме към всяко поле с неговоте име. т.е. можем да си мислим, че декларирайки променлива от тази структура, ние получавам място в паметта, което има няколко адреса. Използвайки нотацията с . можем да достъпваме всяко под поле от променливата.  Ето и един пример, как можем да боравим с отделните части на структурата.

```swift
var phone:Merchandise = Merchandise(name:"Nokia", pricePerUnit:200, isAvailable:false)

func pritnInfoFor(merchandise:Merchandise) {
	print("Product : \(merchandise.name) - 
	\(merchandise.pricePerUnit) - 
	\(merchandise.isAvailable ? "available" : "unavailable")")
}

pritnInfoFor(merchandise: phone)
//Product : Nokia - 200.0 - unavailable
```
 
Създаваме променлива `phone` от вече дефинираната структура `Merchandise` (стока). Във помощната функция `pritnInfoFor(merchandise:Merchandise)` ние изпозлваме нотацията с . `merchandise.name` за да достъпим името на стоката.

Интересно впечатление прави че при инициализиране на променливата от новия тип имаме функция, в която можем да зададем стойност на всяко поле (елемнт от структурата). 

Не можем да зъздадем променлива от типа `Merchandise`, която да не е инициализирана, без да подадем данни.

Тази специална функция, ще наричаме конструктор или `init` метод. Метод за инизиализиране на променливи от този тип.

Можем да мислим, че ако опишем полетата (елементите) на една структура, тогава имаме неявен конструктор, който включва всички полета като аргументи. Ето, какво получваме на готово в случая:

```swift
init(name: String, pricePerUnit: Double, isAvailable:Bool) {
	self.name = name
	self.pricePerUnit = pricePerUnit
	self.isAvailable = isAvailable
}
```

Ако се сблъсквате с подобен код за пръв път, тогава вероятно вече сте си задали следните въпроси:
    
_Какво означава `self`?_

`self` е запазена дума, която ни позволява да се обръщаме към мястото в паметта, където се съхраняват данните. Посредством нея, можем да адресираме отделните полета и да достъпваме стойностите им. В горния случай, правим просто копиране на данните в полетата от структурата. Интересно е да отбележим, че `self` се среща в други езици като `this`. `this` не е запазена дума в езика Swift.

_`init` функция ли е?_

Можем да си мислим, че е специална функция (както я определхме по-горе - конструктор). Тя няма тип на резултата, който връща и не изпозлва запазената дума `func`. Можем да имаме много разновидности на `init`.

_Защо не извикваме явно функцията `init`?_

Функцията се извика, но няма пряко съответствие между името й и извикването й. За да я извикаме трябва да използваме името на типа данни или в нашия случай името на структурата.
 
Тогава цялостния вид на структурата ще изглежда така:
 
```swift
struct Merchandise {
	var name: String
   	var pricePerUnit: Double
	var isAvailable: Bool
    
    	init(name: String, pricePerUnit: Double, isAvailable:Bool) {
		self.name = name
   	   	self.pricePerUnit = pricePerUnit
   		self.isAvailable = isAvailable 
	}
}
```

Ако искаме да имаме конструктор без параметри трябва да си декларираме такъв. Това е друга "версия" на конструктора - такава без параметри. Ето, как можем да направим това.

```swift
init() {
	self.name = "Noname"
	self.pricePerUnit = 0
	self.isAvailable = false
}
```

Трябва да отбележим, че всяко поле трябва да има стойност или да му бъде присвоена такава в конструктора `init` метода. _Изключение са полетата със стойност по подразбиране._ Можем да дадем такава на всяко поле в нашата структура. Ето и как можем да си спестим конструктора без параметри.

```swift
struct Merchandise {
	var name: String = "noname"
   	var pricePerUnit: Double = 0.0
	var isAvailable: Bool = false
}
```

След като имаме такъв конструктор можем да го изпозлваме така:

```swift
var newPhone:Merchandise = Merchandise()
		
pritnInfoFor(merchandise: newPhone)
//Product : Noname - 0.0 - unavailable
```
	
Логично е да си зададем въпроса, ако имаме инициализиране, какво става, когато освобождаваме паметта. Процеса можем да наричаме деинициализация. Структурите __нямат__ деинициализиращ метод `deinit`. Ако се опитате да декларирате такъв, компилатора ще ви подскаже, че това е метод, който се среща само при класовете. Така, че когато ползваме структури, трябва да мислим за тяхната иницализация, а всичко останало оставяме на Swift.

Нека сега да видим как можем да добавим операции (или собствени функции) към една структура. Операциите са функции, които ни позволяват да боравим по-лесно със структурите.

Ще добавим функция `printInfo`, която отпечатва данните за един продукт. Ще взаимстваме логиката от вече познатата ни функция `func pritnInfoFor(merchandise:Merchandise)`

```swift
func printInfo() {
	print("Product : \(name) - \(pricePerUnit) - \(isAvailable ? "available" : "unavailable")")
}
```

Цялостния вид на нашата структура е следния:

```swift
struct Merchandise {
	var name: String
	var pricePerUnit: Double
	var isAvailable: Bool
    
	init() {
		self.name = "Noname"
		self.pricePerUnit = 0
		self.isAvailable = false
    	}
    	
	init(name: String, pricePerUnit: Double, isAvailable:Bool) {
		self.name = name
		self.pricePerUnit = pricePerUnit
		self.isAvailable = isAvailable
    	}
    
	func printInfo() {
		print("Product : \(name) - \(pricePerUnit) - \(isAvailable ? "available" : "unavailable")")
	}
}
```
	
Нека сега да сравним тази функция с горната. Намаме резултат, който да връщат. Това е еднакво. Едната взема параметър, а другата не взема. Това е така, защото функцията, която е част от структурата може да оперира с данните в структурата. Това обяснява  защо и от къде идват полетата `name`, `pricePerUnit`, `isAvailable` респективно данните в тях. Да, можем да използваме `self` пред всяко поле, т.е. `self.name` и `name` означават едно и също.
    
Множеството от полета и функции (операции) над структурата определят интерфейса за боравене с този тип данни.

Можем да изпозлваме всички неща които знаем за функциите от предходната лекция и да ги прилагаме когато дефинираме функции, като часто то структура. Можем да имаме __inout__ параметри. Може да имаме неопределен брои парамтри. Това правим, като изпозлваме __...__ след типа на променливата. Променливата се преобразува до масив от параметри, от типа преди __...__. Ето и един пример за такава функция:

```swift
func maxValue(params numbers:Int...) -> Int {
	var max = Int.min
	for v in numbers {
		if max < v {
			max = v
		}
	}
    
	return max
}
```

Можем и да връщаме резултат от определен тип. 

Да на правим леко отклонение и да разясним някои базови типове като `Array`. Това е колекция от еднакви по тип данни. 

Ето пример за списък от цели числа:

```swift
let integers = [1, 2, 3]
print(integers)
let reversed = integers.reversed()
//print(reversed) //this is from strange type
print([Int](reversed))

//[1, 2, 3]
//[3, 2, 1]
```

Тук извикваме функцията `reversed()`, която връща копие на списъка, но елементите за подредение в обратен ред. 


### Предаване по стойност

Структурите, както и стандартните типове данни, които познаваме се предават по стойност, когато подаваме параметри на функция. 

_Какво е предаване по стойност?_

Това означава, че когато имаме нова променлива, и направим присвояване компютъра извършва копиране на данните в паметта. Ето и един пример, който може да онагледи това поведение:

```swift
var a = 1
var b = a
print("Initial values:")
print("a = \(a)")
print("b = \(b)")
	
a += 5
print("Modify a += 5.")
print("a = \(a)")
print("b = \(b)")
	
func modify(value:inout Int) {
	value = 3
}
	
print("Example with functions.")
print("b = \(b)")
modify(value: &b)
print("Modify b = 3.")
print("b = \(b)")
	
//изход в конзолата:
//Initial values:
//a = 1
//b = 1
//Modify a += 5.
//a = 6
//b = 1
//Example with functions.
//b = 1
//Modify b = 3.
//b = 3
```

Същият пример реализиран и с променлива от тип структура (тип който ние сме си дефинирали по-горе):

```swift
var nokia = Merchandise(name: "Nokia 3310", pricePerUnit: 100, isAvailable: false)
nokia.printInfo()
var nokiaDiscounted = nokia
nokiaDiscounted.pricePerUnit *= (100.0 - 20.0) / 100.0 // -20%
nokiaDiscounted.isAvailable = true
nokiaDiscounted.printInfo()
nokia.printInfo() 
```

Какво остава да научим за структурите?

Subscripts - достъп до елементи изпозлвайки синтаксиса `[]`

Индексирането е лесен начин за достъп до елементите на колекция, списък или последователност от елементи. Употребата я виждаме при работата с колекции от стандартните типове, като масив или речник(dictionary).

```swift
var goods = [Merchandise(), Merchandise(), Merchandise()]
goods[1].isAvailable = true // достъп до първия елемент
```

Класическата форма е:

```swift
subscript (index:Int) -> Any {
	get {
    		//връщаме подходяща стойност 
   	}
        
	set(newValue) {
    		//променяме данните в структурата
    	}
}
```

Имаме `get` и `set` част. Като различна част от кода се задейства в зависимост дали ще присвояваме стойност с `=` или ще използваме стойността връщана от `get`. Можем да дефинираме произволни форми, които вземата параметър от тип различен от цяло число.

Примерно:

```swift
subscript (index:(Int,Int)) -> Any {
   	return "tuple nothing"
}
```
    
Достъпа до елементите може да има различно значение в зависимост от типа на данните върху които се прилага. 

Трябва да отбележим, че `subscript` е специален вид функция, която не позволява употребата на __inout__ параметри и параметри със стойности по подразбиране.

__Extensions__ - добавяне на допълнителни функции към структура

Разширенията (Extensions) дават възможност да добавяме функционалност към структури и класове. Можем да добавим:

* можем да добавяме методи към обекта (функции) или към типа данни (static)
* да дефинираме достъп чрез subscript - []
* добавяне на __вложение типове__

Протоколи - лесен начин да дефинираме интерфейс. Приложими са към структури и към класове. За тях ще кажем повече, в следващата секция.

Структура, която е присвоена на константа използвайки `let` не може да модифицира своите пропъртита. Т.е. тя става константна структура. Това е обяснява с това, че когат един тип редаван по стойност е изпозлван за да инициализра константа, тогава всички негови злен данни стават константни, независимо дали са били променливи.

Ето и пример:

```swift
let g1 = Merchandise()
//това предизвиква грешка 
g1.name = "New name" //note: change 'let' to 'var' to make it mutable
```

#### Модифициращи методи

Структурите имат член данни, които можем да достъпваме с точкова нотация `newPhone.printInfo()`. Ако искаме да напишем функция, която модифицира член данните, трябва да използваме запазента дума `mutating` за да подскажем на компилатора, че дадената функция, ще модифицира структурата изпозлвайки `self`. Това става, като слагаме `mutating` преди `func`. Ето и пример с нашата структура.

### Изчислими пропъртита

Това са пропъртита, които се изчисляват в момента на обръщение към тях. По идея приличат на функция, която връща резултат, но няма параметри. Разликата е това, че в кода изглеждат, като нормални пропъртита. Ето и един пример, който показва такива пропъртита.

_Изчислимото пропърти е добавено в оделно разширение._

```swift
extension Merchandise {
 	//изчислими пропъртита
   	var incomePerUnit:Double {
    		get {
    			return self.pricePerUnit * 0.2
		}
	}
}
	
var macBookPro = Merchandise(name:"MacBook Pro 15\"", pricePerUnit: 3200.0, isAvailable: true)
print("Income per product: \(macBookPro.incomePerUnit)")
```
	
#### Изчислими пропъртита с допълнителна логика

Пропъртитата може да връщат стойнот, но могат и да приемат стойност. Добре е да знаем, че можем да предефинираме стандартното им поведение. Т.е. може да имаме пропърти, което да записва стойности в различни части от структурата, както и да връща резултат (да бъде изчислимо), базиран на няколко член данни (други пропъртита или функции). Ето един пример:

```swift
extension Merchandise {	
	var realPricePerUnit:Double {
		get {
	    		return self.pricePerUnit * 0.8
	    	}
	        
	    	set (newValue) {
	    		self.pricePerUnit = newValue * 1.25
	    	}
	}
}
```
    
Има и къс вариант на тази дефиниция:

```swift
extension Merchandise {	
	var realPricePerUnit:Double {
		get {
	    		return self.pricePerUnit * 0.8
	    	}
	        
		set {
	    		//newValue е името на параметъра. Типът е Double
	        	self.pricePerUnit = newValue * 1.25
	    }
	}
}
```

Когато имаме само `get` метод, тогава говорим за read–only пропъртита. Такива, които можем само да изпозлваме, като част от израз, но не и да присвояваме някаква стойност. Такъв пример имаме по-горе `incomePerUnit`.
Можем да изпозлваме по-кратък синтаксис за да го запишем така:

```swift
extension Merchandise {
    
	//изчислими пропъртита
	var incomePerUnit:Double {
    		return self.pricePerUnit * 0.2
   	}
}
```

#### Мързеливи пропъртита

Това са пропъртита, които са инициализиранни при тяхната първа употреба. Те трявба да се маркират с ключовата дума `lazy`. Те трбява винаги за да променливи `var`.

```swift
struct LazyStruct {
	var count: Int
	init (count:Int) {
		print("\(LazyStruct.self) се конструира чрез -> \(#function)")
		self.count = count
	}
}
	
struct ExampleLazyProperty {
	lazy var s:LazyStruct = LazyStruct(count: 5)
	var regularInt = 5
	    
	init() {
		print("\(ExampleLazyProperty.self) се конструира чрез -> \(#function)")
	}
}
	
var lazyPropExample = ExampleLazyProperty()
lazyPropExample.regularInt = 15
print("Стойноста в нормалното пропърти 'regularInt' e \(lazyPropExample.regularInt)")
print("Стойноста на мързеливото пропърти е \(lazyPropExample.s.count)")
print("Стойноста в нормалното пропърти 'regularInt' е \(lazyPropExample.regularInt)")
```

### Полезни ресурси

__Ето къде можем да прочетем повече за дизайна на API-та и генерализирането на [функции](http://www.generic-programming.org/)__

__Тук може да намерим примерни [playground](https://github.com/kushtaneja/iPad_Swift_Playgrounds)-и__

## Класове

Темата ще бъде разгледана в следващата статия.
